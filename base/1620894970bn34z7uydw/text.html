<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:11pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="wow0"></a><span style=" font-size:14pt; font-weight:600; color:#000000;">П</span><span style=" font-size:14pt; font-weight:600; color:#000000;">ростейшая токенизация</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">Алгоритмы для строк, заданные в заголовочном файле &lt;boost/algorithm/string.hpp&gt;, предоставляют готовые шаблонные функции «replace_all» для поиска и замены подстроки, «trim» для обрезания пробелов слева и справа, «split» для разделения строки на массив подстрок, разделённых символом-разделителем и другие.</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p>
<p style=" margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">Для разбиения текста на слова подходит boost::split. Рассмотрим пример ниже:</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:40px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">vector&lt;string&gt; SplitWords(string const&amp; text)</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:40px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">{</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:40px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">	std::string trimmed = boost::trim_copy(text);</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:40px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">	vector&lt;string&gt; words;</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:40px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">	boost::split(words, trimmed, boost::is_space(), boost::token_compress_on);</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:40px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">	return words;</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:40px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" color:#000000;" style=" margin-top:0px; margin-bottom:0px; margin-left:30px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:18px;">предикат, возвращённый функцией ‘boost::is_space()’, отмечает пробельные символы как разделители</span></li>
<li style=" color:#000000;" style=" margin-top:0px; margin-bottom:0px; margin-left:30px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:18px;">token_compress_on гарантирует склеивание нескольких пробельных символов в один</span></li>
<li style=" color:#000000;" style=" margin-top:0px; margin-bottom:15px; margin-left:30px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:18px;">‘boost::trim’ убирает пробельные символы в начале и в конце текста (иначе в words окажутся пустые слова)</span></li></ul>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:x-large; font-weight:600;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="wow1"></a><span style=" font-size:14pt; font-weight:600;">Т</span><span style=" font-size:14pt; font-weight:600;">окенизация на основе регулярных выражений</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">Стандартная библиотека регулярных выражений, которая появилась в C++ 2011 в виде заголовка . Он поддерживает поиск по регулярному выражению как на диапазоне итераторов, так и на объекте типа «std::basic_string».</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-style:italic; color:#323232;">Несколько примеров использования regex для задач лексического анализа есть </span><a href="https://github.com/ps-group/compiler-theory-samples/tree/master/std-regex"><span style=" font-style:italic; text-decoration: underline; color:#2a7ae2;">в репозитории github.com/ps-group/compiler-theory-samples (подкаталог std-regex)</span></a></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-style:italic; text-decoration: underline; color:#2a7ae2;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-style:italic; text-decoration: underline; color:#2a7ae2;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="wow2"></a><span style=" font-size:14pt; font-weight:600;">Р</span><span style=" font-size:14pt; font-weight:600;">азбор с возвратом (backtracking parssing) в старом стиле</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">Классы строк языка C++ обеспечивают простые и безопасные ввод, вывод, копирование и конкатенацию строк. Но для многих задач, таких как рекурсивный спуск или любой другой способ разбора грамматик, нужен доступ к произвольным символам (random access) и возможность переместить позицию сканнера. Есть два хороших и один сомнительный способ реализации random access:</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p>
<ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" color:#000000;" style=" margin-top:0px; margin-bottom:0px; margin-left:30px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:18px;">Хранить саму строку и одну или с ней одну или несколько переменных типа «size_t», сохраняющих позицию считывающего автомата</span></li>
<li style=" color:#000000;" style=" margin-top:0px; margin-bottom:0px; margin-left:30px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:18px;">Хранить итераторы начала, конца строки и вспомогательные итераторы, обеспечивающие доступ к сканируемым в данный момент символам. Это предпочтительный способ, начиная с C++ 2011.</span></li>
<li style=" color:#000000;" style=" margin-top:0px; margin-bottom:15px; margin-left:30px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:18px;">Сомнительный способ: получить указатель на начало строки, и использовать арифметику указателей для random access и перемещения сканера. Проблемы могут возникнуть и при откате разбора строки, и при проверке выхода за пределы строки</span></li></ol>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:14pt; font-weight:600;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="wow3"></a><span style=" font-size:14pt; font-weight:600;">Р</span><span style=" font-size:14pt; font-weight:600;">азбор с возвратом (backtracking parssing) на основе string_view</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">Проще всего сделать парсер, работающий с объектами </span><a href="http://htrd.su/wiki/zhurnal/2016/04/29/std_string_view_i_vremennye_obekty"><span style=" text-decoration: underline; color:#2a7ae2;">string_view — невладеющими ссылками на строку</span></a><span style=" color:#000000;">. Реализацию string_view можно раздобыть несколькими способами:</span></p>
<ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" color:#000000;" style=" margin-top:0px; margin-bottom:0px; margin-left:30px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:18px;">Найти компилятор и IDE с поддержкой C++17, в котором </span><span style=" font-size:16px;">&lt;string_view&gt;</span><span style=" font-size:18px;"> и объявленные в этом заголовке классы стали частью стандартной библиотеки</span></li>
<li style=" color:#000000;" style=" margin-top:0px; margin-bottom:0px; margin-left:30px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:18px;">Либо взять тривиальную реализацию на Github, состоящую из одного заголовка: </span><a href="https://github.com/sergey-shambir/string_view/blob/master/string_view.h"><span style=" font-size:18px; text-decoration: underline; color:#2a7ae2;">github.com/sergey-shambir/string_view</span></a></li>
<li style=" color:#000000;" style=" margin-top:0px; margin-bottom:15px; margin-left:30px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:18px;">Либо получить Boost версии 1.61 или выше, в котором есть </span><span style=" font-size:16px;">&lt;boost/utility/string_view.hpp&gt;</span></li></ol>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">По сути string_view — это удобная замена такой структуры для чтения строки слева направо:</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:40px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">struct StringScanState</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:40px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">{</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:40px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">    std::string text;</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:40px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">    size_t position;</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:40px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">};</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p>
<p style=" margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">Ссылка на строку не выделяет память, не освобождает память и никак не влияет на время жизни последовательности символов, размещённой в куче. Задача класса – всего лишь предоставить программный интерфейс, аналогичный «std::string», более безопасный и простой, чем итераторы. Кроме интерфейса строки, у ссылки на строку есть методы «remove_prefix(size_t count)» и «remove_suffix(size_t count)», позволяющие сузить область сканирования строки, или отрезать уже просканированную левую/праву часть. Также есть метод «str()», копирующий и возвращающий владеющую памятью строку.</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p></body></html>