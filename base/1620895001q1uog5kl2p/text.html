<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:11pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">Машинный код (байткод) всегда предназначен для исполнения каким-либо процессором, физическим либо виртуальным. Процессоры (машины) могут быть стековыми либо регистровыми:</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" color:#000000;" style=" margin-top:0px; margin-bottom:0px; margin-left:30px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:18px;">Стековая машина для вычислений использует только стек, постоянно добавляя на него новые значения либо снимая старые, что приводит к непрерывному изменению вершины стека.</span></li>
<li style=" color:#000000;" style=" margin-top:0px; margin-bottom:15px; margin-left:30px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:18px;">Регистровая может использовать стек, но кроме него использует также независимые регистры, распределяя и переиспользуя регистры для последовательных вычисления.</span></li></ul>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-style:italic; color:#323232;">В стековом байткоде виртуальной машины инструкции короче, а сам подход позволяет написать компилятор значительно легче. Регистровый позволяет проводить операции с памятью намного эффективнее, особенно с учётом современных процессоров, которые практически всегда являются регистровыми с программным стеком в оперативной памяти (более медленной, чем регистры).</span></p>
<h2 align="center" style=" margin-top:32px; margin-bottom:10px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="wow0"></a><span style=" font-size:x-large; font-weight:600; color:#000000;">Д</span><span style=" font-size:x-large; font-weight:600; color:#000000;">ерево выражений</span></h2>
<p style=" margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">В большинстве языков символ бинарного оператора ставится между его операндами, например: x + y * z + u. Порядок выполнения операций определяется неявным приоритетом операторов и явно расставленными скобками. Расставим все скобки явно: ((x + (y * z)) + u) (мы пренебрегли правилом ассоциативности, по которому (a + b) + c = a + (b + c)).</span></p>
<p style=" margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">После явной расстановки скобок можно нарисовать эквивалентное дерево, при обходе которого слева направо вычисления будут выполнены корректно.</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p align="center" style=" margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1620895056tncu34nxom.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">В BNF нотации простейшая грамматика выражений выглядит так:</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">expression ::= add_sub_expr</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">add_sub_expr ::= mul_div_expr '+' add_sub_expr</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">    | mul_div_expr '-' add_sub_expr</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">    | mul_div_expr</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">mul_div_expr ::= atom_expr '*' mul_div_expr</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">    | atom_expr '/' mul_div_expr</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">    | atom_expr '%' mul_div_expr</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">    | atom_expr</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">atom_expr ::= [0-9]+</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p>
<h2 align="center" style=" margin-top:32px; margin-bottom:10px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="wow1"></a><span style=" font-size:x-large; font-weight:600; color:#000000;">Т</span><span style=" font-size:x-large; font-weight:600; color:#000000;">рансляция дерева в инструкции стековой машины</span></h2>
<p style=" margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">Если у вас есть построенное дерево выражения, вы можете выполнить трансляцию с помощью обхода дерева слева направо в глубину:</span></p>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" color:#000000;" style=" margin-top:0px; margin-bottom:0px; margin-left:30px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:18px;">каждый узел со значением транслируется в команду push</span></li>
<li style=" color:#000000;" style=" margin-top:0px; margin-bottom:15px; margin-left:30px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:18px;">каждый узел с операцией транслируется в команду этой операции, которая возьмёт операнды со стека</span></li></ul>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">push x </span><span style=" font-style:italic; color:#999988;"># Занести на стек x</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">push y </span><span style=" font-style:italic; color:#999988;"># Занести на стек y</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">push z </span><span style=" font-style:italic; color:#999988;"># Занести на стек z</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">multiply </span><span style=" font-style:italic; color:#999988;"># Снять 2 последних значения со стека и перемножить, результат положить в вершину</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">add </span><span style=" font-style:italic; color:#999988;"># Снять 2 последних значения со стека и сложить, результат положить в вершину</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">push u </span><span style=" font-style:italic; color:#999988;"># Занести на стек u</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">add </span><span style=" font-style:italic; color:#999988;"># Снять 2 последних значения со стека и сложить, результат положить в вершину</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-style:italic; color:#999988;"><br /></p>
<p style=" margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">Если теперь выполнить инструкции, то на стеке останется одно число — результат арифметической операции</span></p>
<h2 align="center" style=" margin-top:32px; margin-bottom:10px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="wow2"></a><span style=" font-size:x-large; font-weight:600; color:#000000;">Т</span><span style=" font-size:x-large; font-weight:600; color:#000000;">рансляция дерева в инструкции регистровой машины</span></h2>
<p style=" margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">Мы покажем способ на примере ассемблера виртуальной регистровой машины LLVM-IR, в котором можно использовать сколько угодно регистров — для этого нужно просто связывать каждое значение с новым имененем, а в остальном использовать те же самые принципы, что и для стековой (более того, в реализации кодогенератора вам наверняка пригодится структура данных “стек” либо рекурсия):</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-style:italic; color:#999988;"># Исходник на компилируемом языке</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">function sqr(x Number) Number</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">    </span><span style=" font-weight:600; color:#000000;">return</span><span style=" color:#000000;"> x </span><span style=" font-weight:600; color:#000000;">*</span><span style=" color:#000000;"> x</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">end</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-style:italic; color:#999988;"># Результат в виртуальном ассемблере LLVM-IR</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">define double @sqr(double </span><span style=" font-weight:600; color:#000000;">%</span><span style=" color:#000000;">x) {</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">entry:</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">  </span><span style=" font-weight:600; color:#000000;">%</span><span style=" color:#000000;">x1 </span><span style=" font-weight:600; color:#000000;">=</span><span style=" color:#000000;"> alloca double </span><span style=" font-style:italic; color:#999988;"># выделяем место для копирования параметра</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">  store double </span><span style=" font-weight:600; color:#000000;">%</span><span style=" color:#000000;">x, double</span><span style=" font-weight:600; color:#000000;">*</span><span style=" color:#000000;"> </span><span style=" font-weight:600; color:#000000;">%</span><span style=" color:#000000;">x1 </span><span style=" font-style:italic; color:#999988;"># копируем параметр в переменную</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">  </span><span style=" font-weight:600; color:#000000;">%</span><span style=" color:#000000;">x2 </span><span style=" font-weight:600; color:#000000;">=</span><span style=" color:#000000;"> load double, double</span><span style=" font-weight:600; color:#000000;">*</span><span style=" color:#000000;"> </span><span style=" font-weight:600; color:#000000;">%</span><span style=" color:#000000;">x1 </span><span style=" font-style:italic; color:#999988;"># вместо push x</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">  </span><span style=" font-weight:600; color:#000000;">%</span><span style=" color:#000000;">x3 </span><span style=" font-weight:600; color:#000000;">=</span><span style=" color:#000000;"> load double, double</span><span style=" font-weight:600; color:#000000;">*</span><span style=" color:#000000;"> </span><span style=" font-weight:600; color:#000000;">%</span><span style=" color:#000000;">x1 </span><span style=" font-style:italic; color:#999988;"># вместо push x</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">  </span><span style=" font-weight:600; color:#000000;">%</span><span style=" color:#000000;">multmp </span><span style=" font-weight:600; color:#000000;">=</span><span style=" color:#000000;"> fmul double </span><span style=" font-weight:600; color:#000000;">%</span><span style=" color:#000000;">x2, </span><span style=" font-weight:600; color:#000000;">%</span><span style=" color:#000000;">x3 </span><span style=" font-style:italic; color:#999988;"># вместо mul</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">  ret double </span><span style=" font-weight:600; color:#000000;">%</span><span style=" color:#000000;">multmp </span><span style=" font-style:italic; color:#999988;"># возвращаем результат</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:15px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-style:italic; color:#323232;">Если число регистров в процессоре ограничено, то придётся распределять свободные регистры по выражениям (хотя проще воспользоваться стековым методом). Хороший алгоритм распределения регистров выходит за рамки этой статьи, но в грубом виде он мог бы выглядеть так: у вас есть набор реальных регистров, имена которых служат ключом в ассоциативном массиве (например, в std::unordered_map), а значение — это указатель на объект Value, временно занимающий регистр (например, shared_ptr&lt;Value&gt;). Этот ассоциативный массив используется для учёта занятых регистров. Если регистры кончились, вы можете выдавить несколько значений на стек (добавив в промежуточный код соответствующие команды копирования), а освободившиеся регистры использовать.</span></p>
<h2 align="center" style=" margin-top:32px; margin-bottom:10px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="wow3"></a><span style=" font-size:x-large; font-weight:600; color:#000000;">У</span><span style=" font-size:x-large; font-weight:600; color:#000000;">пражнения</span></h2>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" color:#000000;" style=" margin-top:0px; margin-bottom:0px; margin-left:30px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:18px;">Напишите программу, которая выполняет разбор арифметического выражения в структуру данных “дерево”, а затем обходит дерево и генерирует линейный список простейших строковых команд работы со стеком: </span><span style=" font-size:16px;">push</span><span style=" font-size:18px;">, </span><span style=" font-size:16px;">add</span><span style=" font-size:18px;"> (добавление), </span><span style=" font-size:16px;">sub</span><span style=" font-size:18px;"> (вычитание), </span><span style=" font-size:16px;">mul</span><span style=" font-size:18px;"> (умножение), </span><span style=" font-size:16px;">div</span><span style=" font-size:18px;"> (деление), </span><span style=" font-size:16px;">mod</span><span style=" font-size:18px;"> (деление по остатку). </span><a href="https://ps-group.github.io/compilers/simple_recursive_parser.html"><span style=" font-size:18px; text-decoration: underline; color:#2a7ae2;">Вы можете взять за основу готовый пример калькулятора на рекурсивном спуске</span></a><span style=" font-size:18px;">.</span></li>
<li style=" color:#000000;" style=" margin-top:0px; margin-bottom:15px; margin-left:30px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:18px;">Добавьте к предыдущей программе функцию, которая получает на вход линейный список строковых команд работы со стеком, и выполняет их интерпретацию, используя массив (или </span><span style=" font-size:16px;">std::vector</span><span style=" font-size:18px;">) в качестве стека вычислений. После выполнения вычислений программа должна выдать распечатку оставшихся на стеке значений. Должны обрабатываться ситуации stack overflow и stack underflow.</span></li></ul>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:18px; color:#000000;"><br /></p></body></html>